


### 工作

##### 公司

1. 高通：软开，测试
2. 英特尔：基带
3. 苹果：开发
4. 小米：物理层算法
5. zheku：wlan算法
6. 中兴：
7. 三星：13.5+2月年终奖+2个月加班费
8. AMD：
9. 亚马逊：
10. 博通：
11. 乐鑫科技：wlan算法，iot
12. 中芯国际
13. 大疆
14. 亚马逊
15. 诺基亚
16. 飞思卡尔
17. ARM

##### 领域

整理phy领域知识，有计划，有步骤的进行
行业洞察：制造业8%，AI视觉/人工智能
考虑方面：公积金、是否有绩效工资、升职加薪处理方式、年终奖、底薪、加班费、夜间加班打车、班车、餐补、保险、食堂、工会、党支部
大平台的优势：资源、人脉、贷款、面子、
### 求婚

### 结婚

1. 出阁宴
2. 回娘家

### 买房

城市不能无限扩大，资源是有限的，所以北京会把一部分职能中心，一部分制造业（应环保要求）剥离到廊坊地区。上海也是同样的道理，在外环外重点投资五大新城，临港承载着设计+制造的重担。买房的话尽量避开五大新城
外环15km内，避开远郊坑盘
楼层在5-8楼，>10层有扬尘
回家搜索下廊坊地区定位
上海五大新城目标定位

1. 颛桥紫薇花园，xxxx
2. 徐汇南
3. 虹桥/徐泾：蟠龙天地

绿中海 泗泾 4.4w
四季都会 宝山 4.8w 一号线终点站
中国铁建花语江南 4.8w 

### 买车

S60

### 投资

回收基金

### 刷题

滑动窗口
    滑动窗口一般用来解决连续子序列问题，注意目标解是连续子序列，非连续问题需要考虑使用动态规划求解

``` python3
for i in range(len(nums)):
    sum_num += nums[i]
    while sum_num >= target:
        sub = i - left + 1
        res = min(res, sub)
        sum_num -= nums[left]
        left += 1
```

链表

虚拟头节点

``` python3
dummy = ListNode(0)
dummy.next = head
cur = dummy
...
return dummy.next
```
    
反转链表

``` python3
pre = None
cur = Head

temp = cur.next
cur.next = pre

pre = cur
cur = temp
```

环形链表

``` python3
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        p = head
        q = slow
        while p != q:
            p = p.next
            q = q.next
        return p
return None
```

哈希表

    * 数组：
    * set：
    * map：要维护红黑树或者符号表，而且还要做哈希函数的运算


查找滑动窗口内的最大值

```python3
win, ret = [], []
for i, v in enumerate(nums):
    if i >= k and win[0] <= i - k:
        win.pop(0)
    while win and nums[win[-1]] <= v:
        win.pop()
    win.append(i)
    if i >= k - 1:
        ret.append(nums[win[0]])
return ret
```    

字符串

KMP：KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了
    前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀

`str.count('#')` 统计#个数

```python3
"""生成next数组
def getnext(self,a,needle):
    next=['' for i in range(a)]
    j,k=0,-1
    next[0]=k
    while(j < len(needle)-1):
        if k==-1 or needle[k]==needle[j]:
            k+=1
            j+=1
            next[j]=k
        else:
            k=next[k]
    return next
"""匹配字符串
a=len(needle)
b=len(haystack)
if a==0:
    return 0
i=j=0
next=self.getnext(a,needle)
while(i<b and j<a):
    if j==-1 or needle[j]==haystack[i]:
        i+=1
        j+=1
    else:
        j=next[j]
if j==a:
    return i-j
else:
    return -1
```

二叉树

深度遍历、广度遍历和回溯一般用来解决路径搜索问题，深度遍历和广度遍历大家熟悉一种即可，一般来说，基于辅助队列的广度优先搜索在算法性能上比递归的深度优先搜索效率更高
    
前序遍历、中序遍历、后序遍历 -- 递归法
    
```python3
def inorderTraversal(self, root: TreeNode) -> List[int]:
    result = []

    def traversal(root: TreeNode):
        if root == None:
            return
        traversal(root.left)    # 左
        result.append(root.val) # 中序
        traversal(root.right)   # 右

    traversal(root)
    return result
```

层序遍历（广度优先遍历）-- 迭代法

```python3
def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
    res = []
    stack = [root]
    while stack:
        mean = 0
        count = 0
        for _ in range(len(stack)):
            node = stack.pop(0)
            count += 1
            mean += node.val
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        res.append(mean / count)
    return res
```

总结：
1. 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
2. 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算
3. 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了

回溯算法

回溯法常用于搜索，判断是否有解。本质是穷举，穷举所有可能，然后选出我们想要的答案。和广度优先搜索适用的场景不同，回溯一般用于判断是否有解，广深法用于求最优解 

```python3
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



动态规划

动态规划中每一个状态一定是由上一个状态推导出来的

    模板：
    1. 确定dp数组（dp table）以及下标的含义
    2. 确定递推公式
    3. dp数组如何初始化
    4. 确定遍历顺序
    5. 举例推导dp数组


01背包

01背包的递推公式为：

``` python3
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环**倒序遍历**！

在求装满背包有几种方法的情况下，dp[0] 初始化为1，递推公式一般为

``` python3
dp[j] += dp[j - nums[i]];
```

完全背包

物品数量无限多

背包容量从小到大去遍历

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。需要判断背包空间大小是否容得下当前物品

多重背包

可以在循环内增加单类物品个数的循环，转化为01背包问题


问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); 

问装满背包有几种方法：dp[j] += dp[j - nums[i]] 

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 


问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 

打家劫舍

买卖股票

分析清楚当前有几种状态
将买、卖、冷冻，降维成两个维度：持有股票和未持有股票
可以通过手写，确定下逻辑关系

子序列问题

编辑距离

### 健身

俯卧撑10*4组


### 文章布局

一篇好的文章最好遵守

* 标题
* 副标题
* 背景图
* 正文
* 标签

国外文章创作地址   https://medium.com/
